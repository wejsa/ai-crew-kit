/**
 * 가격 계산기
 *
 * 주문 가격, 할인, 배송비 계산.
 * 쿠폰(정액/정률), 회원등급 할인, 무료배송 임계값 지원.
 *
 * Task: {{TASK_ID}}
 * Created: {{CREATED_AT}}
 */

// --- 타입 정의 ---

export interface OrderItemInput {
  productId: string;
  productName: string;
  unitPrice: number;
  quantity: number;
}

export interface Coupon {
  code: string;
  type: 'FIXED' | 'PERCENTAGE';
  value: number;        // FIXED: 할인 금액, PERCENTAGE: 할인률 (0~100)
  maxDiscount?: number; // PERCENTAGE 시 최대 할인 금액
  minOrderAmount?: number;
}

export const MemberGrade = {
  NORMAL: 'NORMAL',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  VIP: 'VIP',
  VVIP: 'VVIP',
} as const;

export type MemberGradeType = typeof MemberGrade[keyof typeof MemberGrade];

const gradeDiscountRates: Record<MemberGradeType, number> = {
  [MemberGrade.NORMAL]: 0,
  [MemberGrade.SILVER]: 1,
  [MemberGrade.GOLD]: 3,
  [MemberGrade.VIP]: 5,
  [MemberGrade.VVIP]: 7,
};

// --- 결과 타입 ---

export interface PriceCalculation {
  itemsTotal: number;
  couponDiscount: number;
  gradeDiscount: number;
  shippingFee: number;
  totalAmount: number;
  appliedDiscounts: AppliedDiscount[];
}

export interface AppliedDiscount {
  type: 'COUPON' | 'GRADE';
  description: string;
  amount: number;
}

export interface ItemPriceBreakdown {
  productId: string;
  unitPrice: number;
  quantity: number;
  subtotal: number;
  ratio: number; // 전체 대비 비율 (환불 분배용)
}

// --- 설정 ---

const FREE_SHIPPING_THRESHOLD = 50000;
const DEFAULT_SHIPPING_FEE = 3000;

// --- 가격 계산 ---

export function calculatePrice(
  items: OrderItemInput[],
  memberGrade: MemberGradeType = MemberGrade.NORMAL,
  coupon?: Coupon,
): PriceCalculation {
  const appliedDiscounts: AppliedDiscount[] = [];

  // 1. 상품 합계
  const itemsTotal = items.reduce((sum, item) => sum + item.unitPrice * item.quantity, 0);

  // 2. 쿠폰 할인
  let couponDiscount = 0;
  if (coupon) {
    if (coupon.minOrderAmount && itemsTotal < coupon.minOrderAmount) {
      // 최소 주문금액 미달 — 쿠폰 미적용
    } else if (coupon.type === 'FIXED') {
      couponDiscount = Math.min(coupon.value, itemsTotal);
      appliedDiscounts.push({
        type: 'COUPON',
        description: `쿠폰 ${coupon.code} (${coupon.value.toLocaleString()}원 할인)`,
        amount: couponDiscount,
      });
    } else {
      couponDiscount = Math.floor(itemsTotal * coupon.value / 100);
      if (coupon.maxDiscount) {
        couponDiscount = Math.min(couponDiscount, coupon.maxDiscount);
      }
      appliedDiscounts.push({
        type: 'COUPON',
        description: `쿠폰 ${coupon.code} (${coupon.value}% 할인)`,
        amount: couponDiscount,
      });
    }
  }

  // 3. 등급 할인
  const gradeRate = gradeDiscountRates[memberGrade];
  const gradeDiscount = gradeRate > 0 ? Math.floor((itemsTotal - couponDiscount) * gradeRate / 100) : 0;
  if (gradeDiscount > 0) {
    appliedDiscounts.push({
      type: 'GRADE',
      description: `${memberGrade} 등급 할인 (${gradeRate}%)`,
      amount: gradeDiscount,
    });
  }

  // 4. 배송비
  const afterDiscount = itemsTotal - couponDiscount - gradeDiscount;
  const shippingFee = afterDiscount >= FREE_SHIPPING_THRESHOLD ? 0 : DEFAULT_SHIPPING_FEE;

  // 5. 최종 금액
  const totalAmount = afterDiscount + shippingFee;

  return {
    itemsTotal,
    couponDiscount,
    gradeDiscount,
    shippingFee,
    totalAmount: Math.max(0, totalAmount),
    appliedDiscounts,
  };
}

// --- 부분 환불 계산 ---

export function calculatePartialRefund(
  items: OrderItemInput[],
  cancelItems: { productId: string; quantity: number }[],
  originalCalculation: PriceCalculation,
): number {
  const breakdowns = getItemBreakdowns(items);
  let refundAmount = 0;

  for (const cancel of cancelItems) {
    const breakdown = breakdowns.find(b => b.productId === cancel.productId);
    if (!breakdown) continue;

    const itemRefund = breakdown.unitPrice * cancel.quantity;
    const discountRefund = Math.floor(
      (originalCalculation.couponDiscount + originalCalculation.gradeDiscount) * breakdown.ratio * (cancel.quantity / (items.find(i => i.productId === cancel.productId)?.quantity || 1))
    );
    refundAmount += itemRefund - discountRefund;
  }

  return Math.max(0, refundAmount);
}

function getItemBreakdowns(items: OrderItemInput[]): ItemPriceBreakdown[] {
  const total = items.reduce((sum, item) => sum + item.unitPrice * item.quantity, 0);
  return items.map(item => ({
    productId: item.productId,
    unitPrice: item.unitPrice,
    quantity: item.quantity,
    subtotal: item.unitPrice * item.quantity,
    ratio: total > 0 ? (item.unitPrice * item.quantity) / total : 0,
  }));
}

/**
 * 재고 관리 핸들러
 *
 * 이커머스 재고 처리의 동시성 제어와 예약/확정 패턴을 구현합니다.
 * 주문 생성 시 재고 예약, 결제 완료 시 확정, 취소 시 복원 로직을 포함합니다.
 *
 * 생성일: {{CREATED_AT}}
 * Task: {{TASK_ID}}
 */
package {{PACKAGE_NAME}}.infrastructure.inventory

import jakarta.persistence.*
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

/**
 * 재고 엔티티
 */
@Entity
@Table(name = "inventory")
class Inventory(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false, unique = true)
    val productId: Long,

    @Column(nullable = false)
    var physicalStock: Int,  // 물리적 재고

    @Column(nullable = false)
    var reservedStock: Int = 0,  // 예약된 재고

    @Version
    var version: Long = 0,  // 낙관적 락

    val createdAt: Instant = Instant.now(),
    var updatedAt: Instant = Instant.now()
) {
    /**
     * 가용 재고 = 물리 재고 - 예약 재고
     */
    val availableStock: Int
        get() = physicalStock - reservedStock

    /**
     * 재고 예약 (주문 생성 시)
     */
    fun reserve(quantity: Int) {
        require(quantity > 0) { "예약 수량은 0보다 커야 합니다" }
        require(availableStock >= quantity) { "가용 재고 부족: 요청=$quantity, 가용=$availableStock" }

        reservedStock += quantity
        updatedAt = Instant.now()
    }

    /**
     * 예약 확정 (결제 완료 시) - 물리 재고 차감
     */
    fun confirm(quantity: Int) {
        require(quantity > 0) { "확정 수량은 0보다 커야 합니다" }
        require(reservedStock >= quantity) { "예약 재고 부족: 요청=$quantity, 예약=$reservedStock" }

        reservedStock -= quantity
        physicalStock -= quantity
        updatedAt = Instant.now()
    }

    /**
     * 예약 해제 (취소/타임아웃 시)
     */
    fun release(quantity: Int) {
        require(quantity > 0) { "해제 수량은 0보다 커야 합니다" }
        require(reservedStock >= quantity) { "예약 재고 부족: 요청=$quantity, 예약=$reservedStock" }

        reservedStock -= quantity
        updatedAt = Instant.now()
    }

    /**
     * 재고 복원 (반품 완료 시)
     */
    fun restore(quantity: Int) {
        require(quantity > 0) { "복원 수량은 0보다 커야 합니다" }

        physicalStock += quantity
        updatedAt = Instant.now()
    }
}

/**
 * 재고 예약 정보
 */
@Entity
@Table(name = "inventory_reservation")
class InventoryReservation(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(nullable = false)
    val orderId: Long,

    @Column(nullable = false)
    val productId: Long,

    @Column(nullable = false)
    val quantity: Int,

    @Enumerated(EnumType.STRING)
    var status: ReservationStatus = ReservationStatus.RESERVED,

    val createdAt: Instant = Instant.now(),
    var updatedAt: Instant = Instant.now(),

    val expiresAt: Instant = Instant.now().plusSeconds(900)  // 15분 후 만료
)

enum class ReservationStatus {
    RESERVED,   // 예약됨
    CONFIRMED,  // 확정됨 (결제 완료)
    RELEASED,   // 해제됨 (취소/만료)
    EXPIRED     // 만료됨
}

/**
 * 재고 처리 결과
 */
sealed class InventoryResult {
    data class Success(val reservationId: Long) : InventoryResult()
    data class InsufficientStock(val productId: Long, val requested: Int, val available: Int) : InventoryResult()
    data class NotFound(val productId: Long) : InventoryResult()
    data class AlreadyProcessed(val reservationId: Long) : InventoryResult()
}

/**
 * 재고 관리 서비스
 */
@Component
class InventoryHandler(
    private val inventoryRepository: InventoryRepository,
    private val reservationRepository: InventoryReservationRepository
) {

    /**
     * 재고 예약 (주문 생성 시)
     * 비관적 락을 사용하여 동시성 제어
     */
    @Transactional
    fun reserve(orderId: Long, items: List<OrderItem>): List<InventoryResult> {
        return items.map { item ->
            val inventory = inventoryRepository.findByProductIdWithLock(item.productId)
                ?: return@map InventoryResult.NotFound(item.productId)

            if (inventory.availableStock < item.quantity) {
                return@map InventoryResult.InsufficientStock(
                    productId = item.productId,
                    requested = item.quantity,
                    available = inventory.availableStock
                )
            }

            inventory.reserve(item.quantity)
            inventoryRepository.save(inventory)

            val reservation = InventoryReservation(
                orderId = orderId,
                productId = item.productId,
                quantity = item.quantity
            )
            val saved = reservationRepository.save(reservation)

            InventoryResult.Success(saved.id!!)
        }
    }

    /**
     * 예약 확정 (결제 완료 시)
     */
    @Transactional
    fun confirm(orderId: Long): List<InventoryResult> {
        val reservations = reservationRepository.findByOrderIdAndStatus(orderId, ReservationStatus.RESERVED)

        return reservations.map { reservation ->
            if (reservation.status != ReservationStatus.RESERVED) {
                return@map InventoryResult.AlreadyProcessed(reservation.id!!)
            }

            val inventory = inventoryRepository.findByProductIdWithLock(reservation.productId)
                ?: return@map InventoryResult.NotFound(reservation.productId)

            inventory.confirm(reservation.quantity)
            inventoryRepository.save(inventory)

            reservation.status = ReservationStatus.CONFIRMED
            reservation.updatedAt = Instant.now()
            reservationRepository.save(reservation)

            InventoryResult.Success(reservation.id!!)
        }
    }

    /**
     * 예약 해제 (주문 취소 시)
     */
    @Transactional
    fun release(orderId: Long): List<InventoryResult> {
        val reservations = reservationRepository.findByOrderIdAndStatus(orderId, ReservationStatus.RESERVED)

        return reservations.map { reservation ->
            val inventory = inventoryRepository.findByProductIdWithLock(reservation.productId)
                ?: return@map InventoryResult.NotFound(reservation.productId)

            inventory.release(reservation.quantity)
            inventoryRepository.save(inventory)

            reservation.status = ReservationStatus.RELEASED
            reservation.updatedAt = Instant.now()
            reservationRepository.save(reservation)

            InventoryResult.Success(reservation.id!!)
        }
    }

    /**
     * 재고 복원 (반품 완료 시)
     */
    @Transactional
    fun restore(orderId: Long): List<InventoryResult> {
        val reservations = reservationRepository.findByOrderIdAndStatus(orderId, ReservationStatus.CONFIRMED)

        return reservations.map { reservation ->
            val inventory = inventoryRepository.findByProductIdWithLock(reservation.productId)
                ?: return@map InventoryResult.NotFound(reservation.productId)

            inventory.restore(reservation.quantity)
            inventoryRepository.save(inventory)

            InventoryResult.Success(reservation.id!!)
        }
    }
}

/**
 * 재고 Repository
 */
interface InventoryRepository {
    /**
     * 비관적 락으로 재고 조회 (동시성 제어)
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT i FROM Inventory i WHERE i.productId = :productId")
    fun findByProductIdWithLock(productId: Long): Inventory?

    fun save(inventory: Inventory): Inventory
}

interface InventoryReservationRepository {
    fun findByOrderIdAndStatus(orderId: Long, status: ReservationStatus): List<InventoryReservation>
    fun save(reservation: InventoryReservation): InventoryReservation
}

data class OrderItem(
    val productId: Long,
    val quantity: Int
)

/*
 * 사용 예시:
 *
 * // 1. 주문 생성 시 재고 예약
 * val items = listOf(OrderItem(productId = 1L, quantity = 2))
 * val reserveResults = inventoryHandler.reserve(orderId = 100L, items = items)
 *
 * if (reserveResults.any { it is InventoryResult.InsufficientStock }) {
 *     // 재고 부족 처리
 *     throw InsufficientStockException()
 * }
 *
 * // 2. 결제 완료 시 재고 확정
 * inventoryHandler.confirm(orderId = 100L)
 *
 * // 3. 주문 취소 시 재고 해제
 * inventoryHandler.release(orderId = 100L)
 *
 * // 4. 반품 완료 시 재고 복원
 * inventoryHandler.restore(orderId = 100L)
 */
